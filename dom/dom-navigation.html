<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Dom navigation</title>
</head>
<body>
	
	В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется не undefined, а null.

	<HTML> = document.documentElement
	<BODY> = document.body

	Методы для чтения

	document.{body/documentElement}
		.childNodes - коллекция детей
		.firstChild - первый ребенок
		.lastChild - последний ребенок
	!!! это дети, не потомки
	!!! так как это коллекции, для него недоступны методы массивов
	!!! нельзя перебирать через for..in, так как выведет еще и свойства и методы коллекции

	Для преобразования в массив:

	<script>
		var elemCollect = document.body.childNodes;

		[].forEach.call(elemCollect, function(elem) {
			alert(elem);
		});
	</script>
	<script>
		var elemCollect = document.body.childNodes;
		var elemArr = Array.prototype.slice.call(elemCollect);

		elemArr.forEach(function(elem) {
			alert(elem.tagName);
		});
	</script>


	Навигация по ээлементам

	.parentElement
	.children
	.childElementCount
	.previousElementSibling
	.nextElementSibling
	.firstElementChild
	.lastElementChild
	.hasChildNodes() - есть ли дети


	Исключение
	alert( document.documentElement.parentNode ); // document
	alert( document.documentElement.parentElement ); // null

	В IE8- в children присутствуют узлы-комментарии

	Работа с таблицей

	table
		.rows
		.caption
		.tHead
		.tFoot
		.tBodies

	tbody.rows

	tr
		.cells
		.sectionRowIndex - номер строки в в текущей секции TBODY/THEAD
		.rowIndex - номер строки в таблице
	
	td.cellIndex - номер ячейки в строке

	--------------------------------------------------------------

	Поиск по DOM

	document

		.getElementById(<id>) - поиск по id (хотя можно сразу указывать id, но стандарт требует именно такую форму), возвращает конкретный результат, только в контексте document
	- Браузер поддерживает у себя внутреннее соответствие id -> элемент. Поэтому нужный элемент возвращается сразу. Это очень быстро.

		.getElementsByTagName(<tag>) - возвращает список элементов по названию тэга, регистр не важен, применим в любом контексте(* - все)
		.getElementsByName(<name>) - возвращает список по значению аттрибуту name, только в контексте document
		.getElementsByClassName(<class>) - возвращает список, где существует выбранный class, применим в любом контексте
	- Результаты поиска getElementsBy* – живые! При изменении документа – изменяется и результат запроса.
	- Дело в том, что результат запросов getElementsBy* – это не массив, а специальный объект, имеющий тип NodeList или HTMLCollection. Он похож на массив, так как имеет нумерованные элементы и длину, но внутри это не готовая коллекция, а «живой поисковой запрос».
	<script>
		var elem1 = document.getElementsByTagName('div');
		var elem2 = document.querySelectorAll('div');

		alert(elem1.length, elem2.length); // 2, 2

		document.body.innerHMTL = ''; // чистим

		alert(elem1.length, elem2.length); // 0, 2
	</script>


		.querySelectorAll(<selector>) - возвращает список элементов, которые удовлетворяют css селектор, применим в любом контексте
		.querySelector(<selector>) - первый элемент, который ужовлетворяют css селектор, применим в любом контексте
	- перебирает все элементы, при querySelector - возвращает первый попавшийся, querySelectorAll - собирает в массив. Хранит все данные в кэше до тех пор пока документ не изменится. Если селектор ID то запускается метод getElementById

	elem.matches(<selector>) - возвращает bool при сравнении удовлетворяет ли selector elem'ту (старое название matchesSelector)

	elem.closest(<selector>) - НОВЫЙ МЕТОД бежит по цепочке родителей наверх от текущего эеемент и возвращает первый подходящий (может вернуть себя же)



	Посмотрим, как будут работать браузеры, если нужно выполнить следующий код:
	<script>
	// вместо document может быть любой элемент
	var elems = document.getElementsByTagName('div');
	alert( elems[0] );
	alert( elems[995] );
	alert( elems[500] );
	alert( elems.length );
	</script>
	Способ Firefox
	Перебрать подэлементы document.body в порядке их появления в поддереве. Запоминать все найденные элементы во внутренней структуре данных, чтобы при повторном обращении обойтись без поиска.

	Разбор действий браузера при выполнении кода выше:

	Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.
	Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.
	Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает все найденные.
	Возвращает ранее запомненный элемент с индексом 500, без дополнительного поиска!
	Продолжает обход поддерева с элемента, на котором остановился (995) и до конца. Запоминает найденные элементы и возвращает их количество.
	Способ WebKit
	Перебирать подэлементы document.body. Запоминать только один, последний найденный, элемент, а также, по окончании перебора – длину коллекции.

	Здесь кеширование используется меньше.

	Разбор действий браузера по строкам:

	Браузер создаёт пустую «живую коллекцию» elems. Пока ничего не ищет.
	Перебирает элементы, пока не найдёт первый div. Запоминает его и возвращает.
	Перебирает элементы дальше, пока не найдёт элемент с индексом 995. Запоминает его и возвращает.
	Браузер запоминает только последний найденный, поэтому не помнит об элементе 500. Нужно найти его перебором поддерева. Этот перебор можно начать либо с начала – вперед по поддереву, 500-й по счету) либо с элемента 995 – назад по поддереву, 495-й по счету. Так как назад разница в индексах меньше, то браузер выбирает второй путь и идёт от 995-го назад 495 раз. Запоминает теперь уже 500-й элемент и возвращает его.
	Продолжает обход поддерева с 500-го (не 995-го!) элемента и до конца. Запоминает число найденных элементов и возвращает его.
	Основное различие – в том, что Firefox запоминает все найденные, а Webkit – только последний. Таким образом, «метод Firefox» требует больше памяти, но гораздо эффективнее при повторном доступе к предыдущим элементам.

	А «метод Webkit» ест меньше памяти и при этом работает не хуже в самом важном и частом случае – последовательном переборе коллекции, без возврата к ранее выбранным.

	Запомненные элементы сбрасываются при изменениях DOM.
	Если где-то добавлен новый атрибут элементу – с кешем для getElementsByTagName ничего не произойдёт, так как атрибут никак не может повлиять на результат поиска по тегу.

	
	<ul id="menu">
	  <li>Главная страница</li>
	  <li>Форум</li>
	  <li>Магазин</li>
	</ul>
	<script>
	  var lis = document.body.getElementsByTagName('li');

	  document.body.innerHTML = "";

	  alert( lis.length ); // 0
	</script>
	<script>
	  var menu = document.getElementById('menu');
	  var lis = menu.getElementsByTagName('li');

	  document.body.innerHTML = "";

	  alert( lis.length ); // 3
	</script>











	
</body>
</html>