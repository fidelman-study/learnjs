<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Objects</title>
</head>
<body>
	<p>Удаление свойства - delete property</p>
	<p>Существует ли свойства ('prop' in obj)</p>
	<p>Если свойства несуществует - undefined</p>
	<p>Проверка на существования свойства через (=== undefined) опасна тем, что возможно совойство определено, но не инициализировано</p>
	<p>Проверка через for..in либо </p>
	<p>Object.keys(obj) - перевод названия свойств объекта в массив</p>
	<p>Тип ключей - строка</p>
	<p>Можно задать любой ключ (даже через пробел через квадратные скобки) - (obj['hi i am andrei']</p>
	<p>Ключи можно хранить в переменных (obj.age = 25; var key = 'age';)</p>
	<p>при литеральным определенияем ({}) объекта - свойства можно указывать в ковычках</p>
	<p>Свойства хранятся в объекте по порядку присвоения, если это имя свойства не число, иначе по возрастанию</p>
	<p>Значение this называется контекстом вызова и будет определено в момент вызова функции.</p>
	<p>если this вызвано но не определено вызовет либо object window либо в новом стандарте undefined</p>
	<p>чтобы строить цепочки необходимо чтобы функция возвращала текущий this/obj</p>

	<p>Статичные методы - те которые не привязаны к экземпляру объекта</p>
	<p>Фабричный метод - статичные метод для создания объектов</p>
	<p>Полиморфные методы - методы охватывающие все типы данных</p>
	<p>Преимущества фабричных методов над полиморфными</p>
	<ul>
		<li>Лучшая читаемость кода. Как конструктора – вместо одной большой функции несколько маленьких, так и вызывающего кода – явно видно, что именно создаётся.</li>
		<li>Лучший контроль ошибок, т.к. если в createFromData ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.</li>
		<li>Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: User.createAdmin = function() { ... }. А для полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр – «тип посетителя» и усложнить этим код.</li>
	</ul>
	<script>
	//полиморфный
	function User(userData) {
	  if (userData) { // если указаны данные -- одна ветка if
	    this.name = userData.name;
	    this.age = userData.age;
	  } else { // если не указаны -- другая
	    this.name = 'Аноним';
	  }

	  this.sayHi = function() {
	    alert(this.name)
	  };
	  // ...
	}

	// Использование

	var guest = new User();
	guest.sayHi(); // Аноним

	var knownUser = new User({
	  name: 'Вася',
	  age: 25
	});
	knownUser.sayHi(); // Вася
	</script>



	
	<script>
	// фабричный
	function User() {
	  this.sayHi = function() {
	    alert(this.name)
	  };
	}

	User.createAnonymous = function() {
	  var user = new User;
	  user.name = 'Аноним';
	  return user;
	}

	User.createFromData = function(userData) {
	  var user = new User;
	  user.name = userData.name;
	  user.age = userData.age;
	  return user;
	}

	// Использование

	var guest = User.createAnonymous();
	guest.sayHi(); // Аноним

	var knownUser = User.createFromData({
	  name: 'Вася',
	  age: 25
	});
	knownUser.sayHi(); // Вася
	</script>
</body>
</html>