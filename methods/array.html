<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Array</title>
</head>
<body>
	<p>Коллекция элементов, при которым новый элемент добавляется вконец и при выборе элемента, достается последний добавленный элемент - Последний пришел - первым ушел</p>
	<p>pop() - удаляет последний и выводит его</p>
	<p>push() - добавляет вконец и выводит длину, можно добавлять сразу несколько элементов</p>
	<p>shift() - удаляет первый и выводит его</p>
	<p>unshift() - добавляет вначало и выводит длину, можно добавлять сразу несколько элементов</p>
	<p>Методы push/pop выполняются быстро, а shift/unshift – медленно.</p>
	<p>при добавления через индекс - выводится добавленный элемент</p>
	<p>цикл for(var i=0; i < arr.length...) надёжнее и быстрее чем for..in</p>
	<p>length - последний индекс + 1</p>
	<p>При уменьшении length массив укорачивается, процесс необратимый</p>
	<p>В конструкции new Array(если 1 аргумент, то это длина, если несколько - это элементы)</p>
	<p>Массив это упорядоченная коллекция, поэтому использовать его нужно изза порядка, иначе это объект</p>
	<p>Массивы это объекты и они хранят ссылки на значения. Если изменить значения клона или оригинала, оригинальньный или клоны соответственно изменятся</p>


	
	<h2>Методы</h2>
	<p>split(separator [, length]) - разбиваем строку на массив (пустой сепаратор "" - разобьет по буквам</p>
	<p>join(separator) - создает из массива на строку</p>
	<p>Трюк - new Array(4).join("ля") - // ляляля</p>
	<p>splice(index[, deleteCount, elem1, ..., elemN]) - изменяет исходный массив</p>
	<ul>
		<li>Удаление - splice(index, length) - Не оставляет дыр и возвращает удаленные элементы</li>
		<li>Замена - splice(index,length, elem, elem ..)</li>
		<li>Вставка - splice(index, 0, elem, elem ..)</li>
		<li>index - отрицательный - сконца (-1 - предпоследний)</li>
	</ul>
	<p>slice(index [, end]) - копирует, end - не включается. Без аргументов копируется весь массив - не изменяет исходный массив</p>
	<p>sort(array) - сортирует строчно, изменяя массив</p>
	<p>reverse(array) - меняет порядок, изменяя массив</p>
	<p>array.concat(elem ,elem) - конкатинация массивов, неизменяя массив</p>
	<p>indexOf/lastIndexOf - как и в string - осуществляют перебор, поэтому для поиска в большом массиве нужно подумать</p>
	<p>Object.keys(obj) - перевод названия свойств объекта в массив</p>
	<p>function compareReversed(a, b) {
		  return b - a;
		}

		arr.sort(compareReversed); - обратная сортировка</p>
	<p>При копировании массив использовать метод slice()</p>



	<h2>Перебор</h2>
	<p>arr.forEach(callback(item, i, arr) - Он для каждого элемента массива вызывает функцию callback.</p>
	<p>arr.filter - Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.</p>
	<p>arr.map - Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.</p>
	<p>Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.</p>
	<p>Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.</p>
	<p>arr.reduce(callback[, initialValue]) - callback(previousValue, currentItem, index, arr) - reduceRight - справа/налево</p>
	<h2>Arguments</h2>

</body>
</html>