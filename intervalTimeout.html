<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>setTimeout setInterval</title>
</head>
<body>
	<script>
	// Задержка в исполнении функции
	var timerId = setTimeout(func / code, delay[, arg1, arg2...])
	// func/code - Функция или строка кода для исполнения. Строка поддерживается для совместимости, использовать её не рекомендуется.
	// delay - Задержка в милисекундах, 1000 милисекунд равны 1 секунде. Минимальная задержка 4мс
	// arg1, arg2.. - Аргументы, которые нужно передать функции. Не поддерживаются в IE9-.

	// Пример
	function func(phrase, who) {
	  alert( phrase + ', ' + who );
	}

	var timerID = setTimeout(func, 1000, "Привет", "Вася"); // Привет, Вася
	clearTimeout(timerID); // Отмена 
	</script>

	<script>
	var timerId = setInterval(func / code, delay[, arg1, arg2...])

	// начать повторы с интервалом 2 сек
	var timerId = setInterval(function() {
	  alert( "тик" );
	}, 2000);

	// через 5 сек остановить повторы
	setTimeout(function() {
	  clearInterval(timerId);
	  alert( 'стоп' );
	}, 5000);
	</script>

	<p>Лучше заменять setInterval рекурсивным setTimeout, так как он гарантирует заданную задержку между выполнением функции</p>
	<p>Время отсчета setInterval начинается перед выполнением функции, то есть функции съедает часть интервала</p>
	<p>Время отсчета setTimeout начинается после выполнения функции</p>

	<script>
		var timerId = setTimeout(function tick() {
			alert('start');
			setTimeout(tick, 1000);
		}, 1000);
	</script>
	<p>
		Планирование setInterval будет вызывать функцию каждые 10 мс после текущего времени. Но так как интерпретатор занят долгой функцией, то до конца ее работы никакого вызова не происходит.

		За время выполнения f может пройти время, на которое запланированы несколько вызовов setInterval, но в этом случае остается только один, т.е. накопления вызовов не происходит. Такова логика работы setInterval.

		После окончания текущего скрипта интерпретатор обращается к очереди запланированных вызовов, видит в ней setInterval и выполняет. А затем тут же выполняется setTimeout, очередь которого тут же подошла.

		Итого, как раз и видим, что setInterval выполнился ровно 1 раз по окончании работы функции. Такое поведение кросс-браузерно.
	</p>
</body>
</html>